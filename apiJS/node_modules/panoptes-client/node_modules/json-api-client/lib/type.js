// Generated by CoffeeScript 1.10.0
(function() {
  var Emitter, Resource, Type, mergeInto,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    slice = [].slice;

  Emitter = require('./emitter');

  Resource = require('./resource');

  mergeInto = require('./merge-into');

  module.exports = Type = (function(superClass) {
    extend(Type, superClass);

    Type.prototype.Resource = Resource;

    Type.prototype._name = '';

    Type.prototype._client = null;

    Type.prototype._links = null;

    Type.prototype._resourcesCache = null;

    function Type(_name, _client) {
      this._name = _name;
      this._client = _client;
      Type.__super__.constructor.apply(this, arguments);
      this._links = {};
      this._resourcesCache = {};
      if (!(this._name && (this._client != null))) {
        throw new Error('Don\'t call the Type constructor directly, use `client.type("things");`');
      }
    }

    Type.prototype.create = function(data, headers, meta) {
      var key, ref, ref1, resource, value;
      if (data == null) {
        data = {};
      }
      if (headers == null) {
        headers = {};
      }
      if (meta == null) {
        meta = {};
      }
      if (data.type && data.type !== this._name) {
        return (ref = this._client.type(data.type)).create.apply(ref, arguments);
      } else {
        resource = (ref1 = this._resourcesCache[data.id]) != null ? ref1 : new this.Resource(this);
        mergeInto(resource._headers, headers);
        mergeInto(resource._meta, meta);
        if (data.id != null) {
          for (key in data) {
            value = data[key];
            if ((indexOf.call(resource._changedKeys, key) < 0) && (!(key in resource._savingKeys))) {
              resource[key] = value;
            }
          }
          this._resourcesCache[resource.id] = resource;
          resource.emit('change');
        } else {
          resource.update(data);
        }
        return resource;
      }
    };

    Type.prototype.get = function() {
      return new Resource.Promise(typeof arguments[0] === 'string' ? this._getByID.apply(this, arguments) : Array.isArray(arguments[0]) ? this._getByIDs.apply(this, arguments) : this._getByQuery.apply(this, arguments));
    };

    Type.prototype._getByID = function() {
      var id, otherArgs;
      id = arguments[0], otherArgs = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      return this._getByIDs.apply(this, [[id]].concat(slice.call(otherArgs))).then(function(arg) {
        var resource;
        resource = arg[0];
        return resource;
      });
    };

    Type.prototype._getByIDs = function() {
      var id, ids, otherArgs, requests;
      ids = arguments[0], otherArgs = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      requests = (function() {
        var i, len, ref, results;
        results = [];
        for (i = 0, len = ids.length; i < len; i++) {
          id = ids[i];
          if (id in this._resourcesCache && (otherArgs.length === 0 || (otherArgs[0] == null))) {
            results.push(Promise.resolve(this._resourcesCache[id]));
          } else {
            results.push((ref = this._client).get.apply(ref, [this._getURL(id)].concat(slice.call(otherArgs))).then(function(arg) {
              var resource;
              resource = arg[0];
              return resource;
            }));
          }
        }
        return results;
      }).call(this);
      return Promise.all(requests);
    };

    Type.prototype._getByQuery = function() {
      var otherArgs, query, ref;
      query = arguments[0], otherArgs = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      return (ref = this._client).get.apply(ref, [this._getURL(), query].concat(slice.call(otherArgs)));
    };

    Type.prototype._getURL = function() {
      return ['', this._name].concat(slice.call(arguments)).join('/');
    };

    return Type;

  })(Emitter);

}).call(this);

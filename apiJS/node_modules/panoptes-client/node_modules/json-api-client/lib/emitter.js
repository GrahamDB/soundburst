// Generated by CoffeeScript 1.10.0
(function() {
  var DEFAULT_SIGNAL, Emitter, arraysMatch, callHandler,
    slice = [].slice;

  DEFAULT_SIGNAL = 'change';

  arraysMatch = function(array1, array2) {
    var i, item, matches, ref;
    matches = (function() {
      var j, len, results;
      results = [];
      for (i = j = 0, len = array1.length; j < len; i = ++j) {
        item = array1[i];
        if (array2[i] === item) {
          results.push(i);
        }
      }
      return results;
    })();
    return (array1.length === (ref = array2.length) && ref === matches.length);
  };

  callHandler = function(handler, payload) {
    var boundArgs, context, ref;
    if (Array.isArray(handler)) {
      ref = handler, context = ref[0], handler = ref[1], boundArgs = 3 <= ref.length ? slice.call(ref, 2) : [];
      if (typeof handler === 'string') {
        handler = context[handler];
      }
    } else {
      boundArgs = [];
    }
    handler.apply(context, boundArgs.concat(payload));
  };

  module.exports = Emitter = (function() {
    Emitter.prototype._callbacks = null;

    function Emitter() {
      this._callbacks = {};
    }

    Emitter.prototype.listen = function() {
      var arg, base, callback, j, signal;
      arg = 2 <= arguments.length ? slice.call(arguments, 0, j = arguments.length - 1) : (j = 0, []), callback = arguments[j++];
      signal = arg[0];
      if (signal == null) {
        signal = DEFAULT_SIGNAL;
      }
      if ((base = this._callbacks)[signal] == null) {
        base[signal] = [];
      }
      this._callbacks[signal].push(callback);
      return this;
    };

    Emitter.prototype.stopListening = function() {
      var arg, callback, handler, i, index, j, k, ref, signal;
      arg = 2 <= arguments.length ? slice.call(arguments, 0, j = arguments.length - 1) : (j = 0, []), callback = arguments[j++];
      signal = arg[0];
      if (signal == null) {
        signal = DEFAULT_SIGNAL;
      }
      if (this._callbacks[signal] != null) {
        if (callback != null) {
          if (Array.isArray(callback)) {
            index = -1;
            ref = this._callbacks[signal];
            for (i = k = ref.length - 1; k >= 0; i = k += -1) {
              handler = ref[i];
              if (Array.isArray(handler)) {
                if (arraysMatch(callback, handler)) {
                  index = i;
                  break;
                }
              }
            }
          } else {
            index = this._callbacks[signal].lastIndexOf(callback);
          }
          if (index !== -1) {
            this._callbacks[signal].splice(index, 1);
          }
        } else {
          this._callbacks[signal].splice(0);
        }
      }
      return this;
    };

    Emitter.prototype.emit = function() {
      var callback, j, len, payload, ref, signal;
      signal = arguments[0], payload = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      if (signal == null) {
        signal = DEFAULT_SIGNAL;
      }
      if (signal in this._callbacks) {
        ref = this._callbacks[signal];
        for (j = 0, len = ref.length; j < len; j++) {
          callback = ref[j];
          callHandler(callback, payload);
        }
      }
      return this;
    };

    Emitter.prototype.destroy = function() {
      var callback, j, len, ref, signal;
      this.emit('destroy');
      for (signal in this._callbacks) {
        ref = this._callbacks[signal];
        for (j = 0, len = ref.length; j < len; j++) {
          callback = ref[j];
          this.stopListening(signal, callback);
        }
      }
    };

    return Emitter;

  })();

}).call(this);

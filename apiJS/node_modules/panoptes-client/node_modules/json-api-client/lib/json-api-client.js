// Generated by CoffeeScript 1.10.0
(function() {
  var DEFAULT_HEADERS, Emitter, JSONAPIClient, Model, READ_OPS, RESERVED_TOP_LEVEL_KEYS, Resource, Type, WRITE_OPS, makeHTTPRequest, mergeInto,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    slice = [].slice;

  makeHTTPRequest = require('./make-http-request');

  mergeInto = require('./merge-into');

  Emitter = require('./emitter');

  Type = require('./type');

  Model = require('./model');

  Resource = require('./resource');

  DEFAULT_HEADERS = require('./default-headers');

  RESERVED_TOP_LEVEL_KEYS = ['meta', 'links', 'linked', 'data'];

  READ_OPS = ['HEAD', 'GET'];

  WRITE_OPS = ['POST', 'PUT', 'DELETE'];

  JSONAPIClient = (function(superClass) {
    var fn, i, len, method, ref;

    extend(JSONAPIClient, superClass);

    JSONAPIClient.prototype.root = '/';

    JSONAPIClient.prototype.headers = null;

    JSONAPIClient.prototype.params = null;

    JSONAPIClient.prototype.reads = 0;

    JSONAPIClient.prototype.writes = 0;

    JSONAPIClient.prototype._typesCache = null;

    function JSONAPIClient(root, headers1, mixins) {
      this.root = root;
      this.headers = headers1 != null ? headers1 : {};
      this.params = {};
      JSONAPIClient.__super__.constructor.call(this, null);
      this._typesCache = {};
      mergeInto(this, mixins);
    }

    JSONAPIClient.prototype.beforeEveryRequest = function() {
      return Promise.resolve();
    };

    JSONAPIClient.prototype.request = function(method, url, payload, headers) {
      return this.beforeEveryRequest().then((function(_this) {
        return function() {
          var allHeaders, fullPayload, fullURL, request;
          method = method.toUpperCase();
          fullURL = _this.root + url;
          fullPayload = mergeInto({}, _this.params, payload);
          allHeaders = mergeInto({}, DEFAULT_HEADERS, _this.headers, headers);
          if (indexOf.call(READ_OPS, method) >= 0) {
            _this.update({
              reads: _this.reads + 1
            });
          } else if (indexOf.call(WRITE_OPS, method) >= 0) {
            _this.update({
              writes: _this.writes + 1
            });
          }
          request = makeHTTPRequest(method, fullURL, fullPayload, allHeaders);
          request["catch"](function() {
            return null;
          }).then(function() {
            if (indexOf.call(READ_OPS, method) >= 0) {
              return _this.update({
                reads: _this.reads - 1
              });
            } else if (indexOf.call(WRITE_OPS, method) >= 0) {
              return _this.update({
                writes: _this.writes - 1
              });
            }
          });
          return request.then(_this.processResponse.bind(_this))["catch"](_this.handleError.bind(_this));
        };
      })(this));
    };

    ref = ['get', 'post', 'put', 'delete'];
    fn = function(method) {
      return JSONAPIClient.prototype[method] = function() {
        return this.request.apply(this, [method].concat(slice.call(arguments)));
      };
    };
    for (i = 0, len = ref.length; i < len; i++) {
      method = ref[i];
      fn(method);
    }

    JSONAPIClient.prototype.processResponse = function(res) {
      var headers, j, k, l, len1, len2, len3, linkedResources, ref1, ref2, ref3, ref4, resourceData, resources, response, results, typeName;
      response = (function() {
        var error;
        try {
          return JSON.parse(res.text);
        } catch (error) {
          return {};
        }
      })();
      headers = res.headers;
      if ('links' in response) {
        this._handleLinks(response.links);
      }
      if ('linked' in response) {
        ref1 = response.linked;
        for (typeName in ref1) {
          linkedResources = ref1[typeName];
          ref2 = [].concat(linkedResources);
          for (j = 0, len1 = ref2.length; j < len1; j++) {
            resourceData = ref2[j];
            this.type(typeName).create(resourceData, headers, response.meta);
          }
        }
      }
      results = [];
      if ('data' in response) {
        ref3 = [].concat(response.data);
        for (k = 0, len2 = ref3.length; k < len2; k++) {
          resourceData = ref3[k];
          results.push(this.type(resourceData.type).create(resourceData, headers, response.meta));
        }
      } else {
        for (typeName in response) {
          resources = response[typeName];
          if (indexOf.call(RESERVED_TOP_LEVEL_KEYS, typeName) < 0) {
            ref4 = [].concat(resources);
            for (l = 0, len3 = ref4.length; l < len3; l++) {
              resourceData = ref4[l];
              results.push(this.type(typeName).create(resourceData, headers, response.meta));
            }
          }
        }
      }
      return results;
    };

    JSONAPIClient.prototype._handleLinks = function(links) {
      var attributeName, href, link, ref1, results1, type, typeAndAttribute, typeName;
      results1 = [];
      for (typeAndAttribute in links) {
        link = links[typeAndAttribute];
        ref1 = typeAndAttribute.split('.'), typeName = ref1[0], attributeName = ref1[1];
        if (typeof link === 'string') {
          href = link;
        } else {
          href = link.href, type = link.type;
        }
        results1.push(this._handleLink(typeName, attributeName, href, type));
      }
      return results1;
    };

    JSONAPIClient.prototype._handleLink = function(typeName, attributeName, hrefTemplate, attributeTypeName) {
      var base, type;
      type = this.type(typeName);
      if ((base = type._links)[attributeName] == null) {
        base[attributeName] = {};
      }
      if (hrefTemplate != null) {
        type._links[attributeName].href = hrefTemplate;
      }
      if (attributeTypeName != null) {
        return type._links[attributeName].type = attributeTypeName;
      }
    };

    JSONAPIClient.prototype.handleError = function() {
      return Promise.reject.apply(Promise, arguments);
    };

    JSONAPIClient.prototype.type = function(name) {
      var base;
      if ((base = this._typesCache)[name] == null) {
        base[name] = new Type(name, this);
      }
      return this._typesCache[name];
    };

    return JSONAPIClient;

  })(Model);

  module.exports = JSONAPIClient;

  module.exports.makeHTTPRequest = makeHTTPRequest;

  module.exports.Emitter = Emitter;

  module.exports.Type = Type;

  module.exports.Model = Model;

  module.exports.Resource = Resource;

}).call(this);

{
    "collab_server" : "",
    "contents" : "library(shiny)\nlibrary(tools)\nlibrary(devtools)\nlibrary(stringr)\nlibrary(shinyFiles)\nlibrary(\"aws.s3\")\nlibrary(shinyTree)\nlibrary(seewave)\nlibrary(tuneR)\nlibrary(httr)\nlibrary(shinyBS)\nlibrary(audio)\nlibrary(sound)\nlibrary(stringr)\nsource(\"createDirectoryTree.r\")\nsource(\"playSound.r\")\nlibrary(\"fftw\")\nlibrary(lubridate)\n\n# Removing previously loaded global environment, if any\nrm(list=ls())\n\n# Global variables\nmainDir <<- NULL\nclipCount <<- 0\nnewName <- NULL\ndepPath <<- NULL\nautoProjectCSVLoad <<- FALSE\nnewSequenceBool <<- FALSE\nautoDepCSVLoad <<- FALSE\nannData <<- list()\nreadSequenceBool <<- FALSE\nannotationListDrop <<- list()\ncurrAnnListGlobal <<- list()\nannotationListWav <<- vector()\nannotationListCsv <<- vector()\nannotationListCsvProject <<- vector()\nprogressValue <<- reactiveValues()\nprogressValue$one <<- 0\nprojectFileCountGlobal <<- 0\nalreadyAnnotated <<- FALSE\nalreadyAnnotatedCount <<- 0\ndropSubmitClicked <<- FALSE\nfirstLoaded <<- TRUE\nprogressBarExists <<- FALSE\n\n\n# This is used to connect correctly with AWS\nset_config( config( ssl_verifypeer = 0L ) )\n\noptions(shiny.trace=TRUE)\noptions(shiny.maxRequestSize=70*1024^2)\nvolumes <- getVolumes()\npaused <<- FALSE\n\ngetOS <- function() {\n  if (.Platform$OS.type == \"windows\") { \n    setWavPlayer(\"afplay\")\n    mainDir <<- \"C:/\"\n    \"win\"\n  } else if (Sys.info()[\"sysname\"] == \"Darwin\") {\n    setWavPlayer(\"afplay\")\n    mainDir <<- \"~\"\n    \"mac\" \n  } else if (.Platform$OS.type == \"unix\") {\n    setWavPlayer(\"aplay\")\n    mainDir <<- \"~\"\n    \"unix\"\n  } else {\n    stop(\"Unknown OS\")\n  }\n}\n\n\nprogressBar <- function(value = 0, label = FALSE, color = \"aqua\", size = NULL,\n                        striped = FALSE, active = FALSE, vertical = FALSE) {\n  stopifnot(is.numeric(value))\n  if (value < 0 || value > 100)\n    stop(\"'value' should be in the range from 0 to 100.\", call. = FALSE)\n  if (!(color %in% shinydashboard:::validColors || color %in% shinydashboard:::validStatuses))\n    stop(\"'color' should be a valid status or color.\", call. = FALSE)\n  if (!is.null(size))\n    size <- match.arg(size, c(\"sm\", \"xs\", \"xxs\"))\n  text_value <- paste0(value, \"%\")\n  style <- htmltools::css(width = text_value)\n  tags$div(\n    class = \"progress\",\n    class = if (!is.null(size)) paste0(\"progress-\", size),\n    tags$div(\n      class = \"progress-bar\",\n      class = paste0(\"progress-bar-\", color),\n      style = style,\n      role = \"progressbar\",\n      `aria-valuenow` = value,\n      `aria-valuemin` = 0,\n      `aria-valuemax` = 100,\n      tags$span(class = if (!label) \"sr-only\", text_value)\n    )\n  )\n}\n\nprogressGroup <- function(text, value, min = 0, max = value, color = \"aqua\") {\n  stopifnot(is.character(text))\n  stopifnot(is.numeric(value))\n  if (value < min || value > max)\n    stop(sprintf(\"'value' should be in the range from %d to %d.\", min, max), call. = FALSE)\n  tags$div(\n    class = \"progress-group\",\n    tags$span(class = \"progress-text\", text),\n    tags$span(class = \"progress-number\", sprintf(\"%d / %d\", value, max)),\n    progressBar(round(value / max * 100), color = color, size = \"sm\")\n  )\n}\n\nshinyServer(function(input, output, session) {\n  \n  # HTML(\"nav\",div(id=\"navbar-title-file-name\", \"Hello\"))\n  \n  projectName <<- NULL\n  spectroFromTime <<- 0\n  spectroToTime <<- 0\n  deploymentCSVDataTable <<- NULL\n  dirPath <<- NULL\n  \n  shinyjs::onclick(\"left-column-title\", toggleProjectSelect())\n  # shinyjs::onclick(\"species-file-upload\", togglecsvFileUploadButton())\n  shinyjs::onclick(\"enter-project-info-label\", toggleProjectInfoDisplay())\n  shinyjs::onclick(\"right-column-title\", toggledeploymentInfoContainer())\n  shinyjs::onclick(\"completedDepContainer\", toggleCompletedDeployment())\n  shinyjs::onclick(\"select-dep-container\", toggleDeploymentSelectDisplay())\n  shinyjs::onclick(\"show-tree\", toggleTree())\n  shinyjs::hide(\"progressOne\")\n  shinyjs::hide(\"tree\")\n  shinyjs::hide(\"directorypath\")\n  shinyjs::hide(\"deployment\")\n  shinyjs::hide(id = \"playButton\",anim = FALSE)\n  shinyjs::hide(id = \"playButtonClipZoom\", anim = FALSE)\n  shinyjs::onclick(\"aws-upload-button\", resetAwsCount())\n  shinyjs::disable(\"aws-upload-button\")\n  shinyjs::onevent('mouseenter', \"csvFile\", showCSVModal())\n  shinyjs::onevent('mouseleave', \"csvFile\", hideCSVModal())\n  \n  # shinyjs::onclick(\"sF-selectButton\", toggleAfterProjectSelect())\n  \n  showCSVModal = function() {\n    shinyjs::show(\"csv-info-modal-container\")\n  }\n  \n  hideCSVModal = function() {\n    shinyjs::hide(\"csv-info-modal-container\")\n  }\n  \n  toggleProjectSelect = function() {\n    shinyjs::toggle(\"directory\", anim = TRUE)\n    shinyjs::toggleClass(\"left-column-title\", \"open-accordian\")\n    shinyjs::toggleClass(\"left-column-title\", \"closed-accordian\")\n  }\n  \n  toggleProjectInfoDisplay = function() {\n    shinyjs::toggle(\"project-info-container\", anim = TRUE)\n    shinyjs::toggleClass(\"enter-project-info-label\", \"open-accordian\")\n    shinyjs::toggleClass(\"enter-project-info-label\", \"closed-accordian\")\n  }\n  \n  toggleDeploymentSelectDisplay = function() {\n    shinyjs::toggle(\"deployment\", anim = TRUE)\n    shinyjs::toggleClass(\"select-dep-container\", \"open-accordian\")\n    shinyjs::toggleClass(\"select-dep-container\", \"closed-accordian\")\n  }\n  \n  togglecsvFileUploadButton = function() {\n    shinyjs::toggle(\"csvFile\", anim = TRUE)\n    shinyjs::toggleClass(\"species-file-upload\", \"open-accordian\")\n    shinyjs::toggleClass(\"species-file-upload\", \"closed-accordian\")\n  }\n  \n  toggledeploymentInfoContainer = function() {\n    shinyjs::toggle(\"species-sidebox-container\", anim = TRUE)\n    shinyjs::toggleClass(\"right-column-title\", \"open-accordian\")\n    shinyjs::toggleClass(\"right-column-title\", \"closed-accordian\")\n  }\n  \n  toggleCompletedDeployment = function() {\n    shinyjs::toggle(\"annotationDrop\", anim = TRUE)\n    shinyjs::toggleClass(\"completedDepContainer\", \"open-accordian\")\n    shinyjs::toggleClass(\"completedDepContainer\", \"closed-accordian\")\n  }\n  \n  #################################\n  ##### This function runs right after the selection of a project is done\n  ##### Mainly toggles classes and set the current directory\n  ################################\n  toggleAfterProjectSelect = function (){\n    shinyjs::hide(\"directory\", anim = TRUE)\n    shinyjs::addClass(\"left-column-title\", \"completed-step\")\n    shinyjs::show(\"directorypath\")\n    shinyjs::show(\"project-info-container\")\n    shinyjs::toggleClass(\"left-column-title\", \"open-accordian\")\n    shinyjs::toggleClass(\"left-column-title\", \"closed-accordian\")\n    shinyjs::toggleClass(\"enter-project-info-label\", \"open-accordian\")\n    shinyjs::toggleClass(\"enter-project-info-label\", \"closed-accordian\")\n    dirPath <<- parseDirPath(roots=c(home=mainDir), input$directory)\n    # Had to check if dirPath was not of length 0 otherwise shiny would return an error\n    # if(length(dirPath) != 0) {\n    #   setwd(normalizePath(dirPath))\n    # }\n  }\n  \n  toggleAfterProjectCsvLoaded = function() {\n    toggleProjectInfoDisplay()\n    shinyjs::addClass(\"enter-project-info-label\", \"completed-step\")\n    toggleDeploymentSelectDisplay()\n  }\n  \n  toggleAfterDeploymentCsvLoaded = function() {\n    shinyjs::hide(\"deployment\", anim = TRUE)\n    shinyjs::removeClass(\"select-dep-container\", \"open-accordian\")\n    shinyjs::addClass(\"select-dep-container\", \"closed-accordian\")\n    shinyjs::addClass(\"right-column-title\", \"completed-step\")\n    shinyjs::removeClass(\"right-column-title\", \"open-accordian\")\n    shinyjs::addClass(\"right-column-title\", \"closed-accordian\")\n  }\n  \n  toggleAfterDeploymentSelect = function (){\n    shinyjs::hide(\"deployment\", anim = TRUE)\n    shinyjs::addClass(\"select-dep-container\", \"completed-step\")\n    shinyjs::show(\"species-sidebox-container\")\n    shinyjs::removeClass(\"select-dep-container\", \"open-accordian\")\n    shinyjs::addClass(\"select-dep-container\", \"closed-accordian\")\n    shinyjs::addClass(\"right-column-title\", \"open-accordian\")\n    shinyjs::removeClass(\"right-column-title\", \"closed-accordian\")\n    shinyjs::addClass(\"show-tree\", \"open-accordian\")\n    shinyjs::removeClass(\"show-tree\", \"closed-accordian\")\n    shinyjs::show(\"tree\", anim = TRUE)\n  }\n  \n  toggleTree = function() {\n    shinyjs::toggleClass(\"show-tree\", \"open-accordian\")\n    shinyjs::toggleClass(\"show-tree\", \"closed-accordian\")\n    shinyjs::toggle(\"directorypath\", anim = TRUE)\n    shinyjs::toggle(\"tree\", anim = TRUE)\n  }\n  \n  getOS()\n  test <- shinyDirChoose(input, 'directory', updateFreq=60000, session=session, root=c(home=mainDir), restrictions=system.file(package='base'), filetypes=c('', '.wav'))\n  \n  observeEvent(input$directory, {\n    toggleAfterProjectSelect()\n    # Removing any .wav files that were copied in the /www folder for sound play\n    wavToRemove <-list.files(paste0(getwd(), \"/www\"), pattern='.wav', full.names = TRUE)\n    unlink(wavToRemove)\n    getOS()\n    dirPath <<- parseDirPath(roots=c(home=mainDir), input$directory)\n    # Get folder name -> which is also the project name\n    projectName <<- gsub(\"^.*\\\\/\", \"\", dirPath)\n    if(file.exists(paste0(dirPath, \"/Project_\", projectName, \".csv\"))) { # CHANGE\n      readProjectCSV(dirPath, projectName)\n      createProjectTree()\n      return()\n    }\n    # Updating the value of the project name input value\n    updateTextInput(session, inputId = \"projectName\", label = NULL, value = projectName)\n    if(length(dirPath)) {\n      createProjectTree()\n    }\n  })\n  \n  createProjectTree = function () {\n    shinyjs::show(\"progressOne\")\n    shinyjs::addClass(\"directory\", \"active-button\")\n    shinyjs::show(\"aws-upload-button\")\n    deploymentSelect <- shinyDirChoose(input, 'deployment', updateFreq=60000, session=session, root=c(home=normalizePath(dirPath)), restrictions=system.file(package='base'), filetypes=c('', '.wav'))\n  }\n  \n  observeEvent(input$deployment, {\n    currAnnList <- list()\n    currAnnListGlobal <<- currAnnList\n    updateSelectizeInput(session, \"annotationDrop\", label = \"Select an annotation\", choices =  currAnnList)\n    depPath <<- parseDirPath(root=c(home=normalizePath(dirPath)), input$deployment)\n    firstTime <<- FALSE\n    if(!is.null(depPath)) {\n      shinyjs::show(\"progressOne\")\n      files <- list.files(depPath, all.files=F, recursive=T, include.dirs=T)\n      sapply(files,FUN=function(eachPath){\n        if (substrRight(eachPath,4) == \".wav\") {\n          if (regexpr('_.*__', eachPath)[1] != -1) {\n            fileName <- paste0(depPath,\"/\",eachPath)\n            fileType <- substrRight(eachPath,4)\n            removeType <- gsub(\".*__\",\"\",eachPath)\n            addProjectName <- paste0(projectName,\"_\", removeType)\n            # timeStringLength <- regexpr('_.*__', eachPath)\n            # matchedString <- timeStringLength + attr(timeStringLength, \"match.length\")-1\n            # fileTime <- substr(eachPath, timeStringLength+1, matchedString-1)\n            # fileNameCountRemoved <- gsub(fileTime,\"_\",eachPath, fixed = TRUE)\n            # updatedFileName1 <- sub(\"_\", \"\",fileNameCountRemoved, fixed = TRUE)\n            # updatedWavFileName <- sub(\"_\", \"\",updatedFileName1, fixed = TRUE)\n            updatedWavFilePath <- paste0(depPath,\"/\",addProjectName)\n            file.rename(fileName,updatedWavFilePath)\n            firstTime <<- TRUE\n          }\n        }\n      })\n      # create_directory_tree(depPath)\n      # load(\"www/dir_tree.Rdata\")\n      # output$tree <- renderTree(tree, quoted = FALSE)\n      shinyjs::addClass(\"deployment\", \"active-button\")\n      deploymentName <<- gsub(\"^.*\\\\/\", \"\", depPath)\n      toggleAfterDeploymentSelect()\n      findFileInfo(firstTime)\n      fileDate <- gsub(\" \", \"-\",minTimeVar, fixed = TRUE)\n      fileDate <- gsub(\":\", \"-\",fileDate, fixed = TRUE)\n      depFileName <- paste0(projectName,\"_\",deploymentName)\n      depFilePath <<- paste0(depPath,\"/\", depFileName, \".csv\")\n      updateTextInput(session, inputId = \"name\", label = NULL, value = deploymentName)\n      if(file.exists(paste0(depPath,\"/\", depFileName, \".csv\"))) { # CHANGE\n        readDeploymentCSV(depPath, depFilePath)\n        findFileCount()\n        return()\n      }\n    }\n  })\n  \n  ###########################\n  ##### Listener for file selection in \"Select Sequence\"\n  ###########################\n  # observeEvent(unlist(get_selected(input$tree)), {\n  #   # Plot main spectrogram\n  #   shinyjs::show(\"loadingContainer1\")\n  #   if (is.null(unlist(get_selected(input$tree))))\n  #   {\n  #     return()\n  #   }\n  #   else {\n  #     spectroFromTime <<- 0\n  #     # Root path of the selected file\n  #     path <- getPath(get_selected(input$tree, \"names\"))\n  #     # Full file path\n  #     currDir <- paste0(depPath, \"/\", path, unlist(get_selected(input$tree)))\n  #     fileType <- substrRight(currDir,4)\n  #     if (fileType != \".wav\") {\n  #       return()\n  #     } else {\n  #       # Reading the sound file\n  #       sound <- readWave(currDir)\n  #       # Duration of the sound file\n  #       durationMain <<- seewave::duration(sound)\n  #       # Storing the start and end time of the wave file in seconds\n  #       l <- length(sound)\n  #       sr <- sound@samp.rate\n  #       soundDuration <- round(l/sr,2)\n  #       # TODO Maybe make a function out of this? Might make the code cleaner\n  #       newSequenceBool <<- TRUE\n  #       if (soundDuration > 59) {\n  #         minuteDuration <- round(soundDuration/60)\n  #         shinyjs::html(\"time-box-label\", paste0(\"This file is \", minuteDuration, \" minutes long. <br> Would you like to increment the display?\"))\n  #         shinyjs::show(\"time-box-container\", anim = TRUE)\n  #         \n  #         # Listener for \"Select a Sequence\"\n  #         observeEvent(input$spectroTimeSubmit, {\n  #           # Getting the increment amount\n  #           incrementAmount <<- as.numeric(input$spectroEndTime) * 60\n  #           spectroToTime <<- incrementAmount\n  #           if (file.exists(depFilePath)) {\n  #             shinyjs::addClass(\"loadingContainer1\", \"loader\")\n  #             readSequenceCSV(unlist(get_selected(input$tree)))\n  #             df <- species()\n  #             itemsType <<- c('Select Species',as.character(df[[1]]))\n  #             itemsSpecies <<- c('Select Type',as.character(df[[3]]))\n  #             updateSelectizeInput(session, \"typeDropdown\", label = \"Type*\", choices =  itemsSpecies)\n  #             updateSelectizeInput(session, \"speciesDropdown\", label = \"Species*\", choices =  itemsType)\n  #           }\n  #           file.copy(currDir, paste0(getwd(), \"/www\"))\n  #           shinyjs::html(id = \"playButton\", paste0(html = '<audio controls preload=\"auto\"><source src=\"', unlist(get_selected(input$tree)), '\" type=\"audio/wav\"></audio>'))\n  #           renderSpectro(sound)\n  #           if (soundDuration > incrementAmount) {\n  #             shinyjs::show(\"spectro-increment-container\")\n  #             shinyjs::show(\"next-spectro-increment\")\n  #           }\n  #           shinyjs::show(\"playButton\",anim = FALSE)\n  #         })\n  #         observeEvent(input$noTimeSubmission,{\n  #           if (file.exists(depFilePath)) {\n  #             sound <- readWave(paste0(depPath, \"/\", unlist(get_selected(input$tree))))\n  #             soundLength <- seewave::duration(sound)\n  #             spectroToTime <<- soundLength\n  #             shinyjs::addClass(\"loadingContainer1\", \"loader\")\n  #             df <- species()\n  #             itemsType <<- c('Select Species',as.character(df[[1]]))\n  #             itemsSpecies <<- c('Select Type',as.character(df[[3]]))\n  #             updateSelectizeInput(session, \"typeDropdown\", label = \"Type*\", choices =  itemsSpecies)\n  #             updateSelectizeInput(session, \"speciesDropdown\", label = \"Species*\", choices =  itemsType)\n  #             readSequenceCSV(unlist(get_selected(input$tree)))  \n  #           }\n  #           spectroToTime <<- soundDuration\n  #           renderSpectro(sound)\n  #           shinyjs::show(\"playButton\",anim = FALSE)\n  #           file.copy(currDir, paste0(getwd(), \"/www\"))\n  #           shinyjs::html(id = \"playButton\", paste0(html = '<audio controls preload=\"auto\"><source src=\"', unlist(get_selected(input$tree)), '\" type=\"audio/wav\"></audio>'))\n  #           shinyjs::removeClass(\"loadingContainer1\", \"loader\")\n  #         })\n  #       } \n  #       else {\n  #         spectroToTime <<- soundDuration\n  #         renderSpectro(sound)\n  #         shinyjs::show(\"playButton\",anim = FALSE)\n  #       }\n  #       shinyjs::show(\"content-id\")\n  #       if(!is.null(newName)) {\n  #         shinyjs::html(\"titleHeader\",newName)\n  #       }\n  #       else {\n  #         shinyjs::html(\"titleHeader\",unlist(get_selected(input$tree)))\n  #       }\n  #     }\n  #   }\n  # }, autoDestroy = FALSE)\n  \n  renderSpectro = function (sound){\n    output$spectrogram <- renderPlot({\n      # Path to the sound file\n      currDir <- paste0(depPath, \"/\", unlist(get_selected(input$tree)))\n      anottationCount <<- 0\n      spectro(sound, osc = FALSE, scale = FALSE, tlim = c(spectroFromTime,spectroToTime), cont=TRUE)\n      shinyjs::show(\"complete-deployment\")\n      shinyjs::removeClass(\"loadingContainer1\", \"loader\")\n    }, res = 72, execOnResize = T)\n  }\n  \n  shinyjs::onclick(\"previous-spectro-increment\", showPreviousSpectroIncrement())\n  shinyjs::onclick(\"next-spectro-increment\", showNextSpectroIncrement())\n  \n  showPreviousSpectroIncrement = function() {\n    path <- getPath(get_selected(input$tree, \"names\"))\n    if(!is.null(newName)) {\n      currDir <- paste0(depPath, \"/\", path, newName)\n    }\n    else {\n      currDir <- paste0(depPath, \"/\", path, unlist(get_selected(input$tree)))\n    }\n    sound <- readWave(currDir)\n    l <- length(sound@stereo)\n    sr <- sound@samp.rate\n    soundDuration <- round(l/sr,2)\n    spectroToTime <<- spectroToTime - incrementAmount\n    spectroFromTime <<- spectroFromTime - incrementAmount\n    renderSpectro(sound)\n    readSequenceCSV(unlist(get_selected(input$tree)))\n    shinyjs::show(\"next-spectro-increment\")\n    if (spectroFromTime == 0) {\n      shinyjs::hide(\"previous-spectro-increment\")\n    }\n    print('clicked')\n  }\n  \n  showNextSpectroIncrement = function() {\n    path <- getPath(get_selected(input$tree, \"names\"))\n    if(!is.null(newName)) {\n      currDir <- paste0(depPath, \"/\", path, newName)\n    }\n    else {\n      currDir <- paste0(depPath, \"/\", path, unlist(get_selected(input$tree)))\n    }\n    sound <- readWave(currDir)\n    l <- length(sound@stereo)\n    sr <- sound@samp.rate\n    shinyjs::show(\"previous-spectro-increment\")\n    durationWav <- seewave::duration(sound)\n    spectroToTime <<- spectroToTime + incrementAmount\n    if(spectroToTime > durationWav) {\n      spectroToTime <<- durationWav\n      if((spectroFromTime + incrementAmount) < durationWav) {\n        spectroFromTime <<- spectroFromTime + incrementAmount\n      }\n    } \n    else {\n      spectroFromTime <<- spectroFromTime + incrementAmount\n    }\n    renderSpectro(sound)\n    readSequenceCSV(unlist(get_selected(input$tree)))\n    shinyjs::show(\"previous-spectro-increment\")\n    if (spectroToTime >= durationWav) {\n      shinyjs::hide(\"next-spectro-increment\")\n    }\n  }\n  \n  ##############################\n  ###### Function that plays the sound after clicking the play button\n  ###### Arg    start       Start time of the sound\n  ###### Arg    end         End time of the sound\n  ###### Arg    chartType   String to know which play button has been pressed (as we have 3 in the app)\n  ##############################\n  playSound = function (start, end, chartType){\n    currTime <- Sys.time()\n    if(paused)\n    {\n      paused <<- FALSE\n      resume(audioSound)\n      if(chartType == \"spectro\")\n      {\n        shinyjs::show(id = \"pauseButton\",anim = TRUE)\n        shinyjs::hide(id = \"playButton\",anim = FALSE)\n      }\n      else if(chartType == \"spectroClipZoom\")\n      {\n        shinyjs::show(id = \"pauseButtonClipZoom\",anim = TRUE)\n        shinyjs::hide(id = \"playButtonClipZoom\",anim = FALSE)\n      }\n      else {\n        shinyjs::show(id = \"pauseButtonClip\",anim = TRUE)\n      }\n    }\n    else {\n      path <- getPath(get_selected(input$tree, \"names\"))\n      if(!is.null(newName)) {\n        currDir <- paste0(depPath, \"/\", path, newName)\n      }\n      else {\n        currDir <- paste0(depPath, \"/\", path, unlist(get_selected(input$tree)))\n      }\n      wave <- readWave(currDir, from = start, to = end, unit = \"seconds\")\n      sound <- audioSample(wave@stereo, wave@samp.rate, wave@bit)\n      if(chartType == \"spectro\")\n      {\n        spectroEnd <- currTime + end\n        shinyjs::show(id = \"pauseButton\",anim = TRUE)\n        shinyjs::hide(id = \"playButton\",anim = FALSE)\n      }\n      else if(chartType == \"spectroClipZoom\")\n      {\n        shinyjs::show(id = \"pauseButtonClipZoom\",anim = TRUE)\n        shinyjs::hide(id = \"playButtonClipZoom\",anim = FALSE)\n      }\n      else {\n        shinyjs::show(id = \"pauseButtonClip\",anim = TRUE)\n      }\n      audioSound <<- audio::play(sound)\n      audioSound\n    }\n  }\n  \n  pauseSound = function (chartType) {\n    paused <<- TRUE\n    pause(audioSound)\n    if(chartType == \"spectro\")\n    {\n      shinyjs::hide(id = \"pauseButton\", anim = TRUE)\n      shinyjs::show(id = \"playButton\", anim = FALSE)\n    }\n    else if (chartType == \"spectroClipZoom\") {\n      shinyjs::hide(id = \"pauseButtonClipZoom\", anim = TRUE)\n      shinyjs::show(id = \"playButtonClipZoom\", anim = FALSE)\n    }\n    else {\n      shinyjs::hide(id = \"pauseButtonClip\", anim = TRUE)\n      shinyjs::show(id = \"playButtonClip\", anim = FALSE)\n    }\n  }\n  \n  getPath = function(folderList) {\n    one <- attr(folderList[[1L]], \"ancestry\", TRUE)\n    path <- paste(one, collapse = \"/\")\n    path <- paste0(path, \"/\")\n    return(path)\n  }\n  \n  # LOAD IN SPECIES DROPDOWN\n  shinyFileChoose(input, 'csvFile', updateFreq=60000, session=session, roots=c(home='~'), restrictions=system.file(package='base'))\n  shinyjs::onclick(\"csvFile\",csvFileSubmitClick())\n  \n  csvFileSubmitClick = function(){\n    csvSumbit <- TRUE\n  }\n  \n  species <- reactive({\n    if (is.null(input$csvFile)) {\n      read.csv(\"www/species-short.csv\", header = TRUE)\n    } else {\n      req(input$csvFile)\n      infile <- parseFilePaths(roots=c(home='~'),input$csvFile)\n      correctPath <- file.path(infile$datapath)\n      print(correctPath)\n      read.csv(correctPath, header = TRUE)\n    }\n  })\n  \n  output$speciesType <- renderUI({\n    \n    df <- species()\n    \n    if (is.null(df)) return(NULL)\n    \n    itemsSpecies <<- c('Select Type',as.character(df[[3]]))\n    selectInput(\"typeDropdown\", \"Type*\",itemsSpecies)\n  })\n  \n  output$commonName <- renderUI({\n    \n    df <- species()\n    \n    \n    if (is.null(df)) return(NULL)\n    \n    itemsType <<- c('Select Species',as.character(df[[1]]))\n    selectInput(\"speciesDropdown\", \"Species*\",itemsType)\n  })\n  \n  formulaText <- reactive({\n    paste(input$speciesDropdown)\n  })\n  #\n  output$speciesName <- renderText({\n    if (length(formulaText())==0) {\n      ''\n    } else if (formulaText()=='Select Species'){\n      ''\n    } else {\n      formulaText()\n    }\n  })\n  \n  observeEvent(input$plot_brush$xmin, {\n    if(input$plot_brush$xmax != 0)\n    {\n      shinyjs::hide(\"time-box-container\", anim = TRUE)\n      spectroClipMin <<- round(input$plot_brush$xmin, digits = 2)\n      spectroClipMax <<- round(input$plot_brush$xmax, digits = 2)\n      spectroClipYMin <<- input$plot_brush$ymin\n      spectroClipYMax <<- input$plot_brush$ymax\n      renderSpectroClip(NULL, spectroClipMin, spectroClipMax, spectroClipYMin, spectroClipYMax, FALSE)\n    }\n  });\n  \n  # Function to create the spectro clip after user has brushed the main plot\n  renderSpectroClip = function(sound, xMinLocal, xMaxLocal, yMinLocal, yMaxLocal, readSequenceBool)\n  {\n    output$spectroClip <- renderPlot({\n      path <- getPath(get_selected(input$tree, \"names\"))\n      if(!is.null(newName)) {\n        currDir <- paste0(depPath, \"/\", path, newName)\n      }\n      else {\n        currDir <- paste0(depPath, \"/\", path, unlist(get_selected(input$tree)))\n      }\n      sound <- readWave(currDir)\n      \n      if(!is.null(xMaxLocal)) {\n        frequencyDF <- get_frequency(currDir, 0, xMaxLocal - xMinLocal, yMinLocal, yMaxLocal)\n        # Calculating the regression line\n        regressionLine <- lm(formula = frequencyDF$y ~ frequencyDF$x)\n        lineSlope <<- regressionLine$coefficients[[\"frequencyDF$x\"]]\n        if(readSequenceBool)\n        {\n          spectro(sound, osc = FALSE, scale = FALSE, tlim = c(xMinLocal,xMaxLocal), flim = c(yMinLocal, yMaxLocal))\n          abline(lm(formula = frequencyDF$y ~ frequencyDF$x), col = \"red\", lty = 1, lwd = 2)\n          readSequenceBool <<- FALSE\n          return()\n        }\n        spectro(sound, f = sound@samp.rate, osc = FALSE, scale = FALSE, tlim = c(floor(xMinLocal),ceiling(xMaxLocal)), flim = c(yMinLocal, yMaxLocal))\n        abline(lm(formula = frequencyDF$y ~ frequencyDF$x), col = \"red\", lty = 1, lwd = 1)\n        # Getting the duration of the clipped graph\n        durationSmall <<- round(xMaxLocal - xMinLocal, digits = 1)\n        shinyjs::show(\"clipInfo-container\")\n        shinyjs::show(\"playButtonClip\",anim = FALSE)\n        # Creating a temp wav sound from xMinLocal to xMaxLocal\n        temp <- extractWave(sound, from = xMinLocal, to = xMaxLocal, xunit = \"time\")\n        # Writing it to a .wav file\n        writeWave(temp, paste0(getwd(), \"/www/temp.wav\"))\n        # Creating an audio tag holding that temp.wav file to be played\n        shinyjs::html(id = \"playButtonClip\", paste0(html = '<audio src=\"temp.wav\" type=\"audio/wav\" controls></audio>'))\n      }\n      xmin <<- xMinLocal\n      xmax <<- xMaxLocal\n      frequencyDF <- get_frequency(currDir, xMinLocal, xMaxLocal, yMinLocal, yMaxLocal);\n      # Storing some variables used for calculating the abline\n      ablineY <<- frequencyDF$y\n      ablineX <<- frequencyDF$x\n      # Storing the frequencies globaly\n      maxFreq <<- round(max(frequencyDF$y, na.rm = T), digits = 2)\n      minFreq <<- round(min(frequencyDF$y, na.rm = T), digits = 2)\n      meanFreq <<- round(mean(frequencyDF$y, na.rm = T), digits = 2)\n      bandwidth <<- round((maxFreq - minFreq), digits = 2)\n      showSpeciesDropdown(xMinLocal, xMaxLocal, maxFreq, minFreq, meanFreq, bandwidth, lineSlope)\n    })\n  }\n  \n  get_frequency <- function(currDir, xMinLocal, xMaxLocal, yMinLocal, yMaxLocal) {\n    freqSound <- readWave(currDir, from = xMinLocal, to = xMaxLocal, units = c(\"seconds\"))\n    filteredSound <- ffilter(freqSound, from = yMinLocal * 1000, to = yMaxLocal * 1000, output = \"Wave\", fftw = T)\n    finalFreq <- dfreq(filteredSound, fftw = T, clip = 0.11, plot = F)\n    df <- as.data.frame(finalFreq)\n  }\n  \n  showSpeciesDropdown = function (xmin, xmax, maxFreq, minFreq, meanFreq, bandwidth, lineSlope){\n    shinyjs::show(\"clip-species-dropdown\")\n    if(!is.null(xmax)) {\n      shinyjs::html(\"timeMin\", paste0(\"Start Time \",round(xmin, digits = 2)))\n      shinyjs::html(\"timeMax\", paste0(\"End Time \",round(xmax, digits = 2)))\n      shinyjs::html(\"maxFreq\", paste0(\"Max \",round(maxFreq, digits = 2)))\n      shinyjs::html(\"minFreq\", paste0(\"Min \",round(minFreq, digits = 2)))\n      shinyjs::html(\"meanFreq\", paste0(\"Mean \",round(meanFreq, digits = 2)))\n      shinyjs::html(\"bandwidth\", paste0(\"Bandwidth \",round(bandwidth, digits = 2)))\n      shinyjs::html(\"slope\", paste0(\"Slope \",round(lineSlope, digits = 4)))\n    } else {\n      shinyjs::html(\"timeMin\", c(\"Start Time \",paste(0)))\n      shinyjs::html(\"timeMax\", c(\"End Time \",paste(0)))\n      shinyjs::html(\"maxFreq\", c(\"Max \",paste(0)))\n      shinyjs::html(\"minFreq\", c(\"Min \",paste(0)))\n      shinyjs::html(\"meanFreq\", c(\"Mean \",paste(0)))\n      shinyjs::html(\"bandwidth\", c(\"Bandwidth \",paste(0)))\n      shinyjs::html(\"slope\", c(\"Slope \",paste(0)))\n    }\n  }\n  \n  shinyjs::onclick(\"close-species-drop\",shinyjs::hide(\"clip-species-dropdown\"))\n  shinyjs::hide(\"clip-species-dropdown\")\n  \n  siteFields <- c(\"name\", \"lat\", \"lon\", \"recId\", \"siteNotes\")\n  # Getting user input data from the deployment info\n  formDataSite <- reactive({\n    data <- sapply(siteFields, function(x) input[[x]])\n    data\n  })\n  \n  # NOT CURRENTLY CALLED\n  createCSVFilePath = function(){\n    if(!is.null(newName)) {\n      fileName <- sub(\".wav\", \"\", newName)\n      return(fileName)\n    } else {\n      fileFullName <- unlist(get_selected(input$tree))\n      fileName <- sub(\".wav\", \"\", fileFullName)\n      return(fileName)\n    }\n  }\n  \n  ######################################\n  ####### Observe event for the site information at the bottom right of the app\n  ######################################\n  observeEvent(input$deploymentInfo, {\n    # Getting the site data\n    data <- formDataSite()\n    files <- list.files(depPath, all.files=F, recursive=T, include.dirs=T)\n    sapply(files,FUN=function(eachPath){\n      if (substrRight(eachPath,4) == \".wav\") {\n        if (!grepl(paste0(\"_\",data[[4]],\"_\"),eachPath)){\n          fileName <- paste0(depPath,\"/\",eachPath)\n          removeProjectName <- gsub(paste0(projectName),\"\",eachPath)\n          addProjectNameAndDeployment <- paste0(projectName,\"_\",data[[4]], removeProjectName)\n          updatedWavFilePath <- paste0(depPath,\"/\",addProjectNameAndDeployment)\n          file.rename(fileName,updatedWavFilePath)\n        }\n      }\n    })\n    create_directory_tree(depPath)\n    load(\"www/dir_tree.Rdata\")\n    output$tree <- renderTree(tree, quoted = FALSE)\n    observeEvent(unlist(get_selected(input$tree)), {\n      shinyjs::hide(\"next-spectro-increment\")\n      shinyjs::hide(\"spectro-increment-container\")\n      # Plot main spectrogram\n      shinyjs::show(\"loadingContainer1\")\n      if (is.null(unlist(get_selected(input$tree))))\n      {\n        return()\n      }\n      else {\n        spectroFromTime <<- 0\n        # Root path of the selected file\n        path <- getPath(get_selected(input$tree, \"names\"))\n        # Full file path\n        currDir <- paste0(depPath, \"/\", path, unlist(get_selected(input$tree)))\n        fileType <- substrRight(currDir,4)\n        if (fileType != \".wav\") {\n          return()\n        } else {\n          # Reading the sound file\n          sound <- readWave(currDir)\n          # Duration of the sound file\n          durationMain <<- seewave::duration(sound)\n          # Storing the start and end time of the wave file in seconds\n          l <- length(sound)\n          sr <- sound@samp.rate\n          soundDuration <- round(l/sr,2)\n          # TODO Maybe make a function out of this? Might make the code cleaner\n          newSequenceBool <<- TRUE\n          if (soundDuration > 59) {\n            minuteDuration <- round(soundDuration/60)\n            shinyjs::html(\"time-box-label\", paste0(\"This file is \", minuteDuration, \" minutes long. <br> Would you like to increment the display?\"))\n            shinyjs::show(\"time-box-container\", anim = TRUE)\n            \n            # Listener for \"Select a Sequence\"\n            observeEvent(input$spectroTimeSubmit, {\n              # Getting the increment amount\n              incrementAmount <<- as.numeric(input$spectroEndTime) * 60\n              spectroToTime <<- incrementAmount\n              if (file.exists(depFilePath)) {\n                shinyjs::addClass(\"loadingContainer1\", \"loader\")\n                readSequenceCSV(unlist(get_selected(input$tree)))\n                df <- species()\n                itemsType <<- c('Select Species',as.character(df[[1]]))\n                itemsSpecies <<- c('Select Type',as.character(df[[3]]))\n                updateSelectizeInput(session, \"typeDropdown\", label = \"Type*\", choices =  itemsSpecies)\n                updateSelectizeInput(session, \"speciesDropdown\", label = \"Species*\", choices =  itemsType)\n              }\n              file.copy(currDir, paste0(getwd(), \"/www\"))\n              shinyjs::html(id = \"playButton\", paste0(html = '<audio controls preload=\"auto\"><source src=\"', unlist(get_selected(input$tree)), '\" type=\"audio/wav\"></audio>'))\n              renderSpectro(sound)\n              if (soundDuration > incrementAmount) {\n                shinyjs::show(\"spectro-increment-container\")\n                shinyjs::show(\"next-spectro-increment\")\n              }\n              shinyjs::show(\"playButton\",anim = FALSE)\n            })\n            observeEvent(input$noTimeSubmission,{\n              if (file.exists(depFilePath)) {\n                sound <- readWave(paste0(depPath, \"/\", unlist(get_selected(input$tree))))\n                soundLength <- seewave::duration(sound)\n                spectroToTime <<- soundLength\n                shinyjs::addClass(\"loadingContainer1\", \"loader\")\n                df <- species()\n                itemsType <<- c('Select Species',as.character(df[[1]]))\n                itemsSpecies <<- c('Select Type',as.character(df[[3]]))\n                updateSelectizeInput(session, \"typeDropdown\", label = \"Type*\", choices =  itemsSpecies)\n                updateSelectizeInput(session, \"speciesDropdown\", label = \"Species*\", choices =  itemsType)\n                readSequenceCSV(unlist(get_selected(input$tree)))  \n              }\n              shinyjs::hide(\"spectro-increment-container\")\n              shinyjs::hide(\"next-spectro-increment\")\n              spectroToTime <<- soundDuration\n              renderSpectro(sound)\n              shinyjs::show(\"playButton\",anim = FALSE)\n              file.copy(currDir, paste0(getwd(), \"/www\"))\n              shinyjs::html(id = \"playButton\", paste0(html = '<audio controls preload=\"auto\"><source src=\"', unlist(get_selected(input$tree)), '\" type=\"audio/wav\"></audio>'))\n              shinyjs::removeClass(\"loadingContainer1\", \"loader\")\n            })\n          } \n          else {\n            spectroToTime <<- soundDuration\n            renderSpectro(sound)\n            shinyjs::show(\"playButton\",anim = FALSE)\n          }\n          shinyjs::show(\"content-id\")\n          if(!is.null(newName)) {\n            shinyjs::html(\"titleHeader\",newName)\n          }\n          else {\n            shinyjs::html(\"titleHeader\",unlist(get_selected(input$tree)))\n          }\n        }\n      }\n    }, autoDestroy = FALSE)\n    if (!is.null(input$tree)){\n      # Sys.sleep(2)\n      js$fixTree()\n    }\n    if (data[[1]] != input$deployment[[1]][2][[1]]) {\n      newDepPath <- gsub(input$deployment[[1]][2][[1]],data[[1]],depPath)\n      file.rename(depPath,newDepPath)\n      depFilePath <<- gsub(input$deployment[[1]][2][[1]],data[[1]],depFilePath)\n      # paste0(depPath,\"/\", depFileName, \".csv\")\n      depPath <<- newDepPath\n    }\n    # Getting file list\n    files <- list.files(depPath, all.files=F, recursive=T, include.dirs=T)\n    if (data[[1]] == \"\") {\n      shinyjs::show(\"dep-name-warning\")\n    } else if (data[[4]] == \"\") {\n      shinyjs::show(\"dep-name-warning\")\n    } else if (data[[2]] == \"\") {\n      shinyjs::show(\"dep-name-warning\")\n    } else if (data[[3]] == \"\") {\n      shinyjs::show(\"dep-name-warning\")\n    } else {\n      shinyjs::hide(\"dep-name-warning\")\n      shinyjs::hide(\"recid-name-warning\")\n      data <- c(data, as.character(minTimeVar))\n      # Adding the min and max time variables to the data\n      names(data)[6] <- \"start_time_date\"\n      data <- c(data, as.character(maxTimeVar))\n      names(data)[7] <- \"end_time_date\"\n      # Link to the location of the LAT/LON entered by the user, saved into the CSV\n      googleMapsLink <- paste0(\"https://www.google.com/maps/@\", data[[2]], \",\", data[[3]], \",13z\")\n      dataArray <- c(data[[1]],data[[2]],data[[3]],data[[4]],data[[5]],data[[6]],data[[7]], googleMapsLink)\n      dataMatrix <- matrix(dataArray,ncol = length(dataArray), byrow = TRUE)\n      colnames(dataMatrix) <- c(\"Name\", \"Lat\", \"Lon\", \"Record ID\", \"Site Notes\", \"Start\", \"End\", \"Google Maps\")\n      siteDataTable <- as.table(dataMatrix)\n      deploymentCSVDataTable <<- siteDataTable\n      # If we have multiple clips on a given spectro, give a new column name to each clip\n      clipCount <<- 0\n      # Reformating user input\n      fileDate <- gsub(\" \", \"-\",data[[6]], fixed = TRUE)\n      fileDate <- gsub(\":\", \"-\",fileDate, fixed = TRUE)\n      # Creating a new filename out of the metadata\n      newFileName <<- paste0(projectName,\"_\",data[[1]])\n      # Checking for file duplicate\n      fileNameDuplicate <- 0\n      # Checking for file duplicates within that folder\n      for (i in 1:length(files)) {\n        if (files[i] == paste0(newFileName,\".csv\")) {\n          fileNameDuplicate <- as.numeric(fileNameDuplicate) + 1\n        }\n      }\n      # Checking for file duplication, alert if any; otherwise create the file\n      if (fileNameDuplicate == 0 || !autoDepCSVLoad) { # VERIFIY\n        writeDeploymentCSV(siteDataTable)\n      }\n      else if(!autoDepCSVLoad) {\n        shinyjs::show(\"file-name-warning-container\")\n      }\n    }\n  })\n  \n  projectFields <- c(\"projectName\", \"projectNotes\")\n  \n  formDataProject <- reactive({\n    data <- sapply(projectFields, function(x) input[[x]])\n    data\n  })\n  \n  #####################################\n  ###### Project info submit button listener\n  #####################################\n  observeEvent(input$projectInfo, {\n    data <- formDataProject()\n    if (data[[1]] == \"\") {\n      shinyjs::show(\"proj-name-warning\")\n    } else {\n      shinyjs::hide(\"proj-name-warning\")\n      projectInfo(data[[1]], data[[2]])\n      shinyjs::hide(\"directory\", anim = TRUE)\n      shinyjs::addClass(\"projectInfo\", \"active-button\")\n      shinyjs::hide(\"project-info-container\", anim = TRUE)\n      shinyjs::addClass(\"enter-project-info-label\", \"completed-step\")\n      shinyjs::toggleClass(\"enter-project-info-label\", \"open-accordian\")\n      shinyjs::toggleClass(\"enter-project-info-label\", \"closed-accordian\")\n      shinyjs::show(\"deployment\", anim = TRUE)\n      shinyjs::addClass(\"select-dep-container\", \"open-accordian\")\n    }\n  })\n  \n  projectInfo <- function(projectNameArg, projectNotesArg) {\n    data <- formDataProject()\n    dataArray <- c(projectNameArg,projectNotesArg)\n    dataMatrix <- matrix(dataArray,ncol = 2, byrow = TRUE)\n    colnames(dataMatrix) <- c(\"Project Name\", \"Project Notes\")\n    projectData <<- as.table(dataMatrix)\n    oldProjectName <- projectName\n    projectName <<- projectNameArg\n    newDirPath <- gsub(oldProjectName,projectName,dirPath)\n    file.rename(dirPath,newDirPath)\n    dirPath <<- newDirPath\n    write.csv(projectData, paste0(dirPath,\"/\",paste0('Project_', projectName,'.csv')), row.names = FALSE)\n    if (length(annotationListCsv) != 0) {\n      annotationListCsvProject <<- c(annotationListCsv, normalizePath(paste0(dirPath,\"/\",paste0('Project_', projectName,'.csv'))))\n    }\n  }\n  \n  speciesFields <- c(\"speciesDropdown\", \"typeDropdown\", \"annotNotes\")\n  \n  formDataSpecies <- reactive({\n    data <- sapply(speciesFields, function(x) input[[x]])\n    data\n  })\n  \n  # Adding the clip metadata to the spectrogram metadata\n  observeEvent(input$speciesDropSubmit, {\n    dropSubmitClicked <<- TRUE\n    fileFullName <- unlist(get_selected(input$tree))\n    if (is.null(deploymentCSVDataTable) ) {\n      if(!autoDepCSVLoad) {\n        shinyjs::show(\"site-info-warning-container\") \n      }\n    }\n    else {\n      shinyjs::enable(\"aws-upload-button\")\n      dataSet <- formDataSpecies()\n      shinyjs::hide(\"site-info-warning-container\")\n      if (dataSet[[1]] == \"Select Species\") {\n        shinyjs::show(\"type-name-warning\")\n      } \n      else if (dataSet[[2]] == \"Select Type\") {\n        shinyjs::show(\"type-name-warning\")\n      } \n      else {\n        if (clipCount == 0) {\n          dataArray <- c(fileFullName, clipCount, xmin, xmax, durationSmall, dataSet[[2]], dataSet[[1]], maxFreq, minFreq, meanFreq, bandwidth, lineSlope, dataSet[[3]], spectroClipYMin, spectroClipYMax)\n          dataMatrix <- matrix(dataArray,ncol = 15, byrow = TRUE)\n          colnames(dataMatrix) <- c(\"File Name\", \"Annotation#\",\"Time Min (s)\", \"Time Max (s)\", \"Duration\", \"Type\", \"Species\", \"Max Freq\", \"Min Freq\", \"Mean Freq\", \"Bandwidth\", \"Annotation Slope\", \"Annotation Notes\", \"yMin\", \"yMax\")\n          dataTable <- as.table(dataMatrix)\n          deploymentCSVDataTable <<- cbind(deploymentCSVDataTable, dataTable)\n        } \n        else {\n          dataArray <- c(deploymentCSVDataTable[1,1], deploymentCSVDataTable[1,2], deploymentCSVDataTable[1,3], deploymentCSVDataTable[1,4], deploymentCSVDataTable[1,5], deploymentCSVDataTable[1,6], deploymentCSVDataTable[1,7], deploymentCSVDataTable[1,8], fileFullName, clipCount, spectroClipMin, spectroClipMax, durationSmall, dataSet[[2]], dataSet[[1]], maxFreq, minFreq, meanFreq, bandwidth, lineSlope, dataSet[[3]], spectroClipYMin, spectroClipYMax)\n          deploymentCSVDataTable <<- rbind(deploymentCSVDataTable, dataArray)\n        }\n        if(newSequenceBool)\n        {\n          # increaseStatusBar()\n          newSequenceBool <<- FALSE\n        }\n        clipCount <<- clipCount + 1\n        # Creating the path with the file name\n        filePathFull <- paste0(depPath,\"/\",fileFullName)\n        # Adding the file to the list of annotated files for later zipping and S3 upload\n        annotationListWav <<- c(annotationListWav, normalizePath(filePathFull))\n        # If the deployment csv already exists, add metadata to the existing csv\n        if (autoDepCSVLoad) {\n          write.csv(deploymentCSVDataTable,depFilePath, row.names = FALSE)\n          annotationListCsv <<- normalizePath(depFilePath)\n        } else {\n          write.csv(deploymentCSVDataTable, normalizePath(paste0(depPath,\"/\",paste0(newFileName,'.csv'))), row.names = FALSE)\n          annotationListCsv <<- normalizePath(paste0(depPath,\"/\",paste0(newFileName,'.csv')))\n        }\n        shinyjs::addClass('completedDepContainer', \"open-accordian\")\n        shinyjs::removeClass('completedDepContainer', \"closed-accordian\")\n        shinyjs::show(\"annotationDrop\")\n        \n        annotationList <- c(paste0(dataSet[[1]], \" at \" , xmin))\n        annotationListDrop <<- c(annotationListDrop, annotationList)\n        \n        # Updating the global annotations list\n        currAnnListGlobal <<- c(currAnnListGlobal, annotationList)\n        updateSelectizeInput(session, \"annotationDrop\", label = \"Select an annotation\", choices =  currAnnListGlobal, selected = tail(currAnnListGlobal, 1))\n        \n        if(progressBarExists) {\n          progressBarExists <<- TRUE\n          # Create some REACTIVE VALUES\n          awsProgressValue <<- reactiveValues()\n          awsProgressValue$one <<- 0\n          # Creating the progress bar for AWS upload\n          output$awsProgress <- renderUI({\n            progressGroup(text = \"Status\",  value = awsProgressValue$one,   min = 0, max = 3, color = \"green\")\n          })\n        } else {\n          updateProgressBar(getProgressBarValue() + 1)\n        }\n      }\n    }\n  })\n  \n  observeEvent(input$annotationDrop, {\n    # Checking that we actually have an element in the dropdown\n    if(input$annotationDrop != \"\")\n    {        \n      tryCatch({\n        annData <- read.csv(depFilePath)[ ,10:23]\n      }, error=function(e) {\n        print(\"Error with the CSV file. Error #1\")\n      })\n      annCount <<- length(annData[[1]])\n      sound <- readWave(paste0(depPath, \"/\", unlist(get_selected(input$tree))))\n      currentSelectedMin <- trimws(head(strsplit(input$annotationDrop, split=\" at \")[[1]],2)[2], which = \"both\")\n      minLast <- tail(annData[[2]], 1)\n      # If current selection is last element in dropdown\n      if(str_detect(input$annotationDrop, as.character(tail(annData[[6]], 1))) && as.character(currentSelectedMin) == as.character(minLast))\n      {\n        # Getting the last sequence from the deployment metadata\n        minLast <- tail(annData[[2]], 1)\n        maxLast <- tail(annData[[3]], 1)\n        maxFreqLast <- tail(annData[[7]], 1)\n        minFreqLast <- tail(annData[[8]], 1)\n        meanFreqLast <- tail(annData[[9]], 1)\n        bandwidthLast <- tail(annData[[10]], 1)\n        slopeLast <- tail(annData[[11]], 1)\n        annLast <- tail(annData[[12]], 1)\n        csvYMin <- tail(annData[[13]], 1)\n        csvYMax <- tail(annData[[14]], 1)\n        \n        shinyjs::html(\"timeMin\", paste0(\"Start Time \",round(minLast, digits = 2)))\n        shinyjs::html(\"timeMax\", paste0(\"End Time \",round(maxLast, digits = 2)))\n        shinyjs::html(\"maxFreq\", paste0(\"Max \",maxFreqLast))\n        shinyjs::html(\"minFreq\", paste0(\"Min \",minFreqLast))\n        shinyjs::html(\"meanFreq\", paste0(\"Mean \",meanFreqLast))\n        shinyjs::html(\"bandwidth\", paste0(\"Bandwidth \",bandwidthLast))\n        shinyjs::html(\"slope\", paste0(\"Slope \",slopeLast))\n        if (!dropSubmitClicked) {\n          alreadyAnnotated <<- TRUE\n        }\n        updateSelectizeInput(session, \"typeDropdown\", label = \"Type*\", choices =  itemsSpecies, selected = as.character(tail(annData[[5]], 1)))\n        filteredSpecies <- filterSpecies(as.character(tail(annData[[5]], 1)), annCount)\n        updateSelectizeInput(session, \"speciesDropdown\", label = \"Species*\", choices =  as.character(filteredSpecies$Common.Name), selected = as.character(tail(annData[[6]], 1)))\n        updateTextAreaInput(session, 'annotNotes', value = annLast)\n\n        # Creating a temp wav sound from xmin to xmax\n        temp <- extractWave(sound, from = minLast, to = maxLast, xunit = \"time\")\n        writeWave(temp, paste0(getwd(), \"/www/temp.wav\"))\n        renderSpectroClip(sound, minLast, maxLast, csvYMin, csvYMax, TRUE)\n        \n        # Creating an audio tag holding that temp.wav file to be played\n        shinyjs::show(\"playButtonClip\",anim = FALSE)\n        shinyjs::html(id = \"playButtonClip\", paste0(html = '<audio src=\"temp.wav\" type=\"audio/wav\" controls></audio>'))\n        shinyjs::removeClass(\"loadingContainer1\", \"loader\")\n      } else {\n        currentSelectedMin <- trimws(head(strsplit(input$annotationDrop,split=\" at \")[[1]],2)[2], which = \"both\")\n        currentSelectedSpecies <- trimws(head(strsplit(input$annotationDrop,split=\" at \")[[1]],2)[1], which = \"both\")\n        df <- as.data.frame(annData)\n        selectedAnn <- df[which(df$Time.Min..s. == currentSelectedMin & df$Species == currentSelectedSpecies), ]\n        \n        minCurr <- selectedAnn$Time.Min..s.\n        maxCurr <- selectedAnn$Time.Max..s.\n        maxFreqCurr <- selectedAnn$Max.Freq\n        minFreqCurr <- selectedAnn$Min\n        meanFreqCurr <- selectedAnn$Mean.Freq\n        bandwidthCurr <- selectedAnn$Bandwidth\n        lineSlopeCurr <- selectedAnn$Annotation.Slope\n        typeCurr <- selectedAnn$Type\n        speciesCurr <<- selectedAnn$Species\n        annNotes <- selectedAnn$Annotation.Notes\n        csvYMin <- selectedAnn$yMin\n        csvYMax <- selectedAnn$yMax\n        renderSpectroClip(sound, minCurr, maxCurr, csvYMin, csvYMax, TRUE)\n        \n        shinyjs::html(\"timeMin\", paste0(\"Start Time \",round(minCurr, digits = 2)))\n        shinyjs::html(\"timeMax\", paste0(\"End Time \",round(maxCurr, digits = 2)))\n        shinyjs::html(\"maxFreq\", paste0(\"Max \", maxFreqCurr))\n        shinyjs::html(\"minFreq\", paste0(\"Min \", minFreqCurr))\n        shinyjs::html(\"meanFreq\", paste0(\"Mean \", meanFreqCurr))\n        shinyjs::html(\"bandwidth\", paste0(\"Bandwidth \", bandwidthCurr))\n        shinyjs::html(\"slope\", paste0(\"Slope \", lineSlopeCurr))\n        alreadyAnnotated <<- TRUE\n        updateSelectizeInput(session, \"typeDropdown\", label = \"Type*\", choices =  itemsSpecies, selected = as.character(typeCurr))\n        filteredSpecies <- filterSpecies(as.character(typeCurr), annCount)\n        updateSelectizeInput(session, \"speciesDropdown\", label = \"Species*\", choices = as.character(filteredSpecies$Common.Name), selected = as.character(currentSelectedSpecies))\n        updateTextAreaInput(session, 'annotNotes', value = annNotes)\n        \n        # Creating a temp wav sound from xmin to xmax\n        temp <- extractWave(sound, from = minCurr, to = maxCurr, xunit = \"time\")\n        # Writing it to a .wav file\n        writeWave(temp, paste0(getwd(), \"/www/temp.wav\"))\n        # Creating an audio tag holding that temp.wav file to be played\n        shinyjs::show(\"playButtonClip\",anim = FALSE)\n        shinyjs::html(id = \"playButtonClip\", paste0(html = '<audio src=\"temp.wav\" type=\"audio/wav\" controls></audio>'))\n      }\n      \n    }\n  })\n  \n  filterSpecies = function(typeCurr, count) {\n    if(is.null(typeCurr) || length(typeCurr) == 0 || typeCurr != \"Select Type\")\n    {\n      speciesList <- species()\n      speciesDF <- as.data.frame(speciesList)\n      filteredSpecies <- speciesDF[which(speciesDF$Type == typeCurr), ] \n    }\n  }\n  \n  # Listener for animal Type selection dropdown\n  # On change, it refreshes the species list to the its type\n  observeEvent(input$typeDropdown, {\n    if(alreadyAnnotated || alreadyAnnotatedCount < 2) {\n      skipDropdownRefresh <<- TRUE\n      if (nrow(deploymentCSVDataTable) > 0) {\n        for (i in 1:nrow(deploymentCSVDataTable)) {\n          if (ncol(deploymentCSVDataTable) > 8 && deploymentCSVDataTable[i,9] == unlist(get_selected(input$tree))){\n            skipDropdownRefresh <<- FALSE\n          }\n        }\n      }\n      \n      if (!alreadyAnnotated && alreadyAnnotatedCount == 1 && skipDropdownRefresh) {\n        filteredSpecies <- filterSpecies(input$typeDropdown, annCount)\n        currentSelectedSpecies <- trimws(head(strsplit(input$annotationDrop,split = \" at \")[[1]],2)[1], which = \"both\")\n        updateSelectizeInput(session, \"speciesDropdown\", label = \"Species*\", choices =  filteredSpecies$Common.Name)\n      }\n      alreadyAnnotated <<- FALSE\n      alreadyAnnotatedCount <<- alreadyAnnotatedCount + 1\n      dropSubmitClicked <<- FALSE\n    } else if (!alreadyAnnotated || alreadyAnnotatedCount >= 2){\n      alreadyAnnotated <<- FALSE\n      alreadyAnnotatedCount <<- alreadyAnnotatedCount + 1\n      filteredSpecies <- filterSpecies(input$typeDropdown, annCount)\n      currentSelectedSpecies <- trimws(head(strsplit(input$annotationDrop,split = \" at \")[[1]],2)[1], which = \"both\")\n      updateSelectizeInput(session, \"speciesDropdown\", label = \"Species*\", choices =  filteredSpecies$Common.Name)\n      dropSubmitClicked <<- FALSE\n    }\n  })\n  \n  ################################\n  ######## Modal UI for AWS\n  ################################\n  observeEvent(input$awsUploadModal, {\n    awsAccessKey <- input$awsAccessKey\n    awsSecretKey <- input$awsSecretKey\n    awsBucket <- input$awsBucket\n    if(awsBucket == \"\" || awsSecretKey == \"\" || awsAccessKey == \"\" ) {\n      shinyjs::show(\"awsEmptyFieldsContainer\")\n    }\n    else {\n      shinyjs::hide(\"awsEmptyFieldsContainer\")\n      Sys.setenv(\"AWS_ACCESS_KEY_ID\" = input$awsAccessKey, \"AWS_SECRET_ACCESS_KEY\" = input$awsSecretKey)\n      if(bucket_exists(awsBucket)) {\n        # Copy files to temp folder for zipping\n        tempDir <- tempdir()\n        csvDir <- paste0(tempDir, \"/\", projectName)\n        wavDir <- paste0(csvDir, \"/deployment\")\n        # If directory already exists, remove any previous files\n        if(dir.exists(csvDir)) {\n          unlink(csvDir, recursive = TRUE)\n        }\n        data <- formDataProject()\n        projectInfo(data[[1]], data[[2]])\n        dir.create(csvDir)\n        dir.create(wavDir)\n        file.copy(annotationListCsv, wavDir)\n        file.copy(annotationListCsvProject[length(annotationListCsvProject)], csvDir)\n        file.copy(annotationListWav, wavDir)\n        incrementAwsCount()\n        # Zip folder\n        oldwd <- getwd()\n        setwd(tempDir)\n        # Getting the site data\n        data <- formDataSite()\n        # Reformating user input\n        fileDate <- gsub(\" \", \"-\",as.character(minTimeVar), fixed = TRUE)\n        fileDate <- gsub(\":\", \"-\",fileDate, fixed = TRUE)\n        # Creating a new filename out of the metadata\n        newFileName <<- paste0(projectName,\"_\",data[[1]])\n        zipName <- sub('_([^_]*)$', '', newFileName)\n        currDate <- format(Sys.time(), \"%Y%m%d\")\n        fullZipName <- paste0(\"/\", zipName, \"_\", currDate)\n        zip(normalizePath(paste0(dirPath, fullZipName, \".zip\")), paste0(projectName, \"/\"))\n        incrementAwsCount()\n        setwd(oldwd)\n        # Upload to AWS\n        awsUpload <- put_object(file = normalizePath(paste0(dirPath, fullZipName, \".zip\")), bucket = awsBucket)\n        incrementAwsCount()\n        # Resetting annotationListWav to 0\n        annotationListWav <<- vector();\n        annotationListCsv <<- vector();\n      } else {\n        output$warningBucket <- renderUI({\n          tagList(\n            HTML(\"Error: The bucket that you have entered does not exist. Please select another bucket or create one.\")\n          )\n        })\n      }\n    }\n  })\n  \n  awsUpload <- function() {\n    observeEvent(awsUpload, {\n      if(awsUpload[1] == TRUE)\n      {\n        incrementAwsCount();\n      }\n    })\n  }\n  \n  substrRight <- function(x, n){\n    substr(x, nchar(x)-n+1, nchar(x))\n  }\n  \n  findFileCount = function() {\n    projectFileCount <- 0\n    files <- list.files(depPath, all.files=F, recursive=T, include.dirs=T)\n    for (i in 1:length(files)) {\n      if (substrRight(files[i],4) == \".wav\") {\n        projectFileCount <- projectFileCount +1\n        projectFileCountGlobal <<- projectFileCountGlobal + 1\n      }\n    }\n    \n    # Render UI output\n    output$progressOne <- renderUI({\n      progressGroup(text = \"Status\", value = progressValue$one, min = 0, max = projectFileCount, color = \"aqua\")\n    })\n  }\n  \n  #################################\n  ###### Function to increase the count of the status bar\n  #################################\n  increaseStatusBar = function () {\n    progressValue$one <<- progressValue$one + 1\n    if (progressValue$one == projectFileCountGlobal) {\n      shinyjs::hide(\"tree\", anim = TRUE)\n      shinyjs::addClass(\"show-tree\", \"closed-accordian\")\n      shinyjs::addClass(\"show-tree\", \"completed-step\")\n      shinyjs::removeClass(\"show-tree\", \"open-accordian\")\n    } else {\n      \n    }\n  }\n  \n  resetStatusBarCount <- function () {\n    progressValue$one <<- 0\n  }\n  \n  incrementAwsCount = function () {\n    awsProgressValue$one <<- awsProgressValue$one + 1\n  }\n  \n  resetAwsCount = function()\n  {\n    awsProgressValue$one <<- 0\n  }\n  \n  \n  ###############################\n  #### If there is a CSV with the same name as the project folder\n  #### Read it and fill in the input values in \"Enter Project Info\"\n  ##############################\n  readProjectCSV = function(projectDir, projectName) {\n    if(!is.null(projectName))\n    {\n      projectCSV <- read.csv(paste0(projectDir, \"/Project_\", projectName, \".csv\"))\n      updateTextInput(session, inputId = \"projectName\", label = NULL, value = projectCSV$Project.Name[[1]])\n      shinyjs::html(\"projectNotes\", projectCSV$Project.Notes[[1]])\n      toggleAfterProjectCsvLoaded()\n    }\n  }\n  \n  readDeploymentCSV <- function(depPath, depFilePath) {\n    if(!is.null(depPath))\n    {\n      shinyjs::hide(\"species-sidebox-container\", anim = TRUE)\n      shinyjs::toggleClass(\"select-dep-container\", \"open-accordian\")\n      shinyjs::toggleClass(\"select-dep-container\", \"closed-accordian\")\n      resetStatusBarCount()\n      csvFileName <<- gsub(\"^.*\\\\/\", \"\", depPath)\n      deploymentCSV <- read.csv(depFilePath)\n      createDataVarFromCSV(deploymentCSV)\n      updateTextInput(session, inputId = \"name\", label = NULL, value = deploymentCSV$Name[[1]])\n      updateTextInput(session, inputId = \"lat\", label = NULL, value = as.character(deploymentCSV$Lat[[1]]))\n      updateTextInput(session, inputId = \"lon\", label = NULL, value = as.character(deploymentCSV$Lon[[1]]))\n      updateTextInput(session, inputId = \"recId\", label = NULL, value = as.character(deploymentCSV$Record.ID[[1]]))\n      shinyjs::html(\"siteNotes\", deploymentCSV$Site.Notes[[1]])\n      countAnnDone <- getStatusBarCount()\n      updateProgressBar(countAnnDone, TRUE)\n      toggleAfterDeploymentCsvLoaded()\n      autoDepCSVLoad <<- TRUE\n    }\n  }\n  \n  # Update the progress bar with the passed argument (should be a number)\n  updateProgressBar <- function(countAnnDone, deploymentMeta = FALSE) {\n    # Only update the progress bar if we have an empty sequence\n    # The progress bar should only update once for each sequence.\n    if(length(input$annotationDrop) == 0 || deploymentMeta || input$annotationDrop == \"\") {\n      progressValue$one <- as.numeric(countAnnDone)\n    } \n  }\n  \n  # Returns the current progress bar status/value\n  getProgressBarValue <- function() {\n    progressValue$one\n  }\n  \n  createDataVarFromCSV = function (deploymentCSV) {\n    csvLength <- length(deploymentCSV$Name)\n    if (csvLength > 0) {\n      for(i in 1:csvLength) {\n        if (length(as.character(deploymentCSV$Annotation.[[1]])) > 0) {\n          dataArray <- c(as.character(deploymentCSV$Name[[i]]),as.character(deploymentCSV$Lat[[i]]),as.character(deploymentCSV$Lon[[i]]),as.character(deploymentCSV$Record.ID[[i]]), as.character(deploymentCSV$Site.Notes[[i]]), as.character(deploymentCSV$Start[[i]]),as.character(deploymentCSV$End[[i]]),as.character(deploymentCSV$Google.Maps[[i]]),as.character(deploymentCSV$File.Name[[i]]),as.character(deploymentCSV$Annotation.[[i]]),as.character(deploymentCSV$Time.Min..s.[[i]]),as.character(deploymentCSV$Time.Max..s.[[i]]),as.character(deploymentCSV$Duration[[i]]),as.character(deploymentCSV$Type[[i]]),as.character(deploymentCSV$Species[[i]]),as.character(deploymentCSV$Max.Freq[[i]]),as.character(deploymentCSV$Min.Freq[[i]]),as.character(deploymentCSV$Mean.Freq[[i]]),as.character(deploymentCSV$Bandwidth[[i]]), as.character(deploymentCSV$Annotation.Slope[[i]]), as.character(deploymentCSV$Annotation.Notes[[i]]), as.character(deploymentCSV$yMin[[i]]), as.character(deploymentCSV$yMax[[i]]))\n          dataMatrix <- matrix(dataArray,ncol = 23, byrow = TRUE)\n          colnames(dataMatrix) <- c(\"Name\", \"Lat\", \"Lon\", \"Record ID\", \"Site Notes\", \"Start\", \"End\", \"Google Maps\", \"File Name\", \"Annotation#\",\"Time Min (s)\", \"Time Max (s)\", \"Duration\", \"Type\", \"Species\", \"Max Freq\", \"Min Freq\", \"Mean Freq\", \"Bandwidth\", \"Annotation Slope\",\"Annotation Notes\", \"yMin\", \"yMax\")\n          dataTable <- as.table(dataMatrix)\n          if(is.null(deploymentCSVDataTable)) {\n            deploymentCSVDataTable <<- rbind(dataTable)\n          } else {\n            deploymentCSVDataTable <<- rbind(deploymentCSVDataTable, dataArray)\n          }\n          clipCount <<- clipCount + 1\n        } else {\n          dataArray <- c(as.character(deploymentCSV$Name[[i]]),as.character(deploymentCSV$Lat[[i]]),as.character(deploymentCSV$Lon[[i]]),as.character(deploymentCSV$Record.ID[[i]]), as.character(deploymentCSV$Site.Notes[[i]]), as.character(deploymentCSV$Start[[i]]),as.character(deploymentCSV$End[[i]]),as.character(deploymentCSV$Google.Maps[[i]]))\n          dataMatrix <- matrix(dataArray,ncol = 8, byrow = TRUE)\n          colnames(dataMatrix) <- c(\"Name\", \"Lat\", \"Lon\", \"Record ID\", \"Site Notes\", \"Start\", \"End\", \"Google Maps\")\n          dataTable <- as.table(dataMatrix)\n          if(is.null(deploymentCSVDataTable)) {\n            deploymentCSVDataTable <<- rbind(dataTable)\n          } else {\n            deploymentCSVDataTable <<- rbind(deploymentCSVDataTable, dataArray)\n          }\n        }\n      }\n    }\n    create_directory_tree(depPath)\n    load(\"www/dir_tree.Rdata\")\n    output$tree <- renderTree(tree, quoted = FALSE)\n    observeEvent(unlist(get_selected(input$tree)), {\n      # Plot main spectrogram\n      shinyjs::show(\"loadingContainer1\")\n      if (is.null(unlist(get_selected(input$tree))))\n      {\n        return()\n      }\n      else {\n        spectroFromTime <<- 0\n        # Root path of the selected file\n        path <- getPath(get_selected(input$tree, \"names\"))\n        # Full file path\n        currDir <- paste0(depPath, \"/\", path, unlist(get_selected(input$tree)))\n        fileType <- substrRight(currDir,4)\n        if (fileType != \".wav\") {\n          return()\n        } else {\n          # Reading the sound file\n          sound <- readWave(currDir)\n          # Duration of the sound file\n          durationMain <<- seewave::duration(sound)\n          # Storing the start and end time of the wave file in seconds\n          l <- length(sound)\n          sr <- sound@samp.rate\n          soundDuration <- round(l/sr,2)\n          # TODO Maybe make a function out of this? Might make the code cleaner\n          newSequenceBool <<- TRUE\n          if (soundDuration > 59) {\n            minuteDuration <- round(soundDuration/60)\n            shinyjs::html(\"time-box-label\", paste0(\"This file is \", minuteDuration, \" minutes long. <br> Would you like to increment the display?\"))\n            shinyjs::show(\"time-box-container\", anim = TRUE)\n\n            # Listener for \"Select a Sequence\"\n            observeEvent(input$spectroTimeSubmit, {\n              if (as.numeric(input$spectroEndTime) <= 0 || as.numeric(input$spectroEndTime) >= 1 || is.na(as.numeric(input$spectroEndTime))) {\n                shinyjs::show(\"increment-value-warning\")\n              } else {\n                shinyjs::hide(\"increment-value-warning\")\n                # Getting the increment amount\n                incrementAmount <<- as.numeric(input$spectroEndTime) * 60\n                spectroToTime <<- incrementAmount\n                if (file.exists(depFilePath)) {\n                  shinyjs::addClass(\"loadingContainer1\", \"loader\")\n                  readSequenceCSV(unlist(get_selected(input$tree)))\n                  df <- species()\n                  itemsType <<- c('Select Species',as.character(df[[1]]))\n                  itemsSpecies <<- c('Select Type',as.character(df[[3]]))\n                  updateSelectizeInput(session, \"typeDropdown\", label = \"Type*\", choices =  itemsSpecies)\n                  updateSelectizeInput(session, \"speciesDropdown\", label = \"Species*\", choices =  itemsType)\n                }\n                file.copy(currDir, paste0(getwd(), \"/www\"))\n                shinyjs::html(id = \"playButton\", paste0(html = '<audio controls preload=\"auto\"><source src=\"', unlist(get_selected(input$tree)), '\" type=\"audio/wav\"></audio>'))\n                renderSpectro(sound)\n                if (soundDuration > incrementAmount) {\n                  shinyjs::show(\"spectro-increment-container\")\n                  shinyjs::show(\"next-spectro-increment\")\n                }\n                shinyjs::show(\"playButton\",anim = FALSE)\n              }\n            })\n            observeEvent(input$noTimeSubmission,{\n              shinyjs::hide(\"spectro-increment-container\")\n              shinyjs::hide(\"next-spectro-increment\")\n              if (file.exists(depFilePath)) {\n                sound <- readWave(paste0(depPath, \"/\", unlist(get_selected(input$tree))))\n                soundLength <- seewave::duration(sound)\n                spectroToTime <<- soundLength\n                shinyjs::addClass(\"loadingContainer1\", \"loader\")\n                df <- species()\n                itemsType <<- c('Select Species',as.character(df[[1]]))\n                itemsSpecies <<- c('Select Type',as.character(df[[3]]))\n                updateSelectizeInput(session, \"typeDropdown\", label = \"Type*\", choices =  itemsSpecies)\n                updateSelectizeInput(session, \"speciesDropdown\", label = \"Species*\", choices =  itemsType)\n                readSequenceCSV(unlist(get_selected(input$tree)))\n              }\n              spectroToTime <<- soundDuration\n              renderSpectro(sound)\n              shinyjs::show(\"playButton\",anim = FALSE)\n              file.copy(currDir, paste0(getwd(), \"/www\"))\n              shinyjs::html(id = \"playButton\", paste0(html = '<audio controls preload=\"auto\"><source src=\"', unlist(get_selected(input$tree)), '\" type=\"audio/wav\"></audio>'))\n              shinyjs::removeClass(\"loadingContainer1\", \"loader\")\n            })\n          }\n          else {\n            spectroToTime <<- soundDuration\n            renderSpectro(sound)\n            shinyjs::show(\"playButton\",anim = FALSE)\n          }\n          shinyjs::show(\"content-id\")\n          if(!is.null(newName)) {\n            shinyjs::html(\"titleHeader\",newName)\n          }\n          else {\n            shinyjs::html(\"titleHeader\",unlist(get_selected(input$tree)))\n          }\n        }\n      }\n    }, autoDestroy = FALSE)\n    if (!is.null(input$tree)){\n      # Sys.sleep(2)\n      js$fixTree()\n    }\n  #   load(\"www/dir_tree.Rdata\")\n  #   output$tree <- renderTree(tree, quoted = FALSE)\n  # }\n    # load(\"www/dir_tree.Rdata\")\n    # output$tree <- renderTree(tree, quoted = FALSE)\n    # observeEvent(input$tree[1], {\n    #   print('stop me')\n    # }, autoDestroy = FALSE)\n    # if (!is.null(input$tree)){\n    #   # Sys.sleep(2)\n    #   js$fixTree()\n    # }\n  }\n  \n  writeDeploymentCSV <- function(siteDataTable) {\n    shinyjs::hide(\"file-name-warning-container\")\n    \n    count <- 0\n    if(!autoDepCSVLoad)\n    {\n      write.csv(siteDataTable, paste0(depPath,\"/\",paste0(newFileName,'.csv')), row.names = FALSE)\n    }\n    \n    if(!is.null(newName)) {\n      shinyjs::html(\"titleHeader\",newName)\n    }\n    else {\n      shinyjs::html(\"titleHeader\",unlist(get_selected(input$tree)))\n    }\n    shinyjs::addClass(\"deploymentInfo\", \"active-button\")\n    shinyjs::hide(\"species-sidebox-container\")\n    shinyjs::addClass(\"right-column-title\", \"completed-step\")\n    shinyjs::toggleClass(\"right-column-title\", \"open-accordian\")\n    shinyjs::toggleClass(\"right-column-title\", \"closed-accordian\")\n  }\n  \n  readSequenceCSV <- function(wavFileName)\n  { \n    shinyjs::enable(\"aws-upload-button\")\n    toggleCompletedDeployment()\n    annDataFull <- read.csv(depFilePath)\n    # Check if file is empty\n    if(\"File.Name\" %in% colnames(annDataFull)){\n      tryCatch({\n        annData <- annDataFull[ ,9:23]\n      }, error=function(e) {\n        print(\"Error with the CSV file. Error #1\")\n      })\n      # currentSelectedMin <- trimws(head(strsplit(input$annotationDrop,split=\" at \")[[1]],2)[2], which = \"both\")\n      # currentSelectedSpecies <- trimws(head(strsplit(input$annotationDrop,split=\" at \")[[1]],2)[1], which = \"both\")\n      df <- as.data.frame(annData)\n      # Filtering by currently selected sequence\n      selectedWav <- df[which(df$File.Name == wavFileName), ]\n      # Filtering the data frame to get only the data that is within the plot's view\n      selectedWav <- selectedWav[which(selectedWav$Time.Min..s. >= spectroFromTime & selectedWav$Time.Max..s. <= spectroToTime), ]\n      # Ordering the data frame\n      selectedWav <- selectedWav[order(selectedWav$Time.Min..s.), ]\n      # If there are no annotations for that sequence\n      if(length(selectedWav$Annotation.) == 0)\n      {\n        # No annotations, resetting currAnnList\n        currAnnList <- list()\n        currAnnListGlobal <<- currAnnList\n        updateSelectizeInput(session, \"annotationDrop\", label = \"Select an annotation\", choices =  currAnnList)\n        return()\n      }\n      currAnnSize <- length(selectedWav$Annotation.)\n      clipCount <<- length(selectedWav$Annotation.)\n      currAnnList <- list()\n      for(i in 1:currAnnSize) {\n        currSpeciesList <- selectedWav$Species[i]\n        currMinList <- selectedWav$Time.Min..s.[i]\n        currList <- paste0(currSpeciesList, \" at \", currMinList)\n        currAnnList <- c(currAnnList, currList)\n      }\n      currAnnListGlobal <<- currAnnList\n      minLast <- tail(selectedWav[[3]], 1)\n      maxLast <- tail(selectedWav[[4]], 1)\n      maxFreqLast <- tail(selectedWav[[8]], 1)\n      minFreqLast <- tail(selectedWav[[9]], 1)\n      meanFreqLast <- tail(selectedWav[[10]], 1)\n      bandwidthLast <- tail(selectedWav[[11]], 1)\n      slopeLast <- tail(selectedWav[[12]], 1)\n      csvYMin <- tail(selectedWav[[14]], 1)\n      csvYMax <- tail(selectedWav[[15]], 1)\n      \n      typeLast <- tail(selectedWav[[5]], 1)\n      speciesLast <- tail(selectedWav[[6]], 1)\n      sound <- readWave(paste0(depPath, \"/\", wavFileName))\n      readSequenceBool <- TRUE\n      renderSpectroClip(sound, minLast, maxLast, csvYMin, csvYMax, readSequenceBool)\n      # Creating a temp wav sound from xmin to xmax\n      temp <- extractWave(sound, from = minLast, to = maxLast, xunit = \"time\")\n      # Writing it to a .wav file\n      writeWave(temp, paste0(getwd(), \"/www/temp.wav\"))\n      # Creating an audio tag holding that temp.wav file to be played\n      shinyjs::show(\"playButtonClip\",anim = FALSE)\n      shinyjs::html(id = \"playButtonClip\", paste0(html = '<audio src=\"temp.wav\" type=\"audio/wav\" controls></audio>'))\n      df <- species()\n      if (is.null(df)) return(NULL)\n      itemsType <<- c('Select Species',as.character(df[[1]]))\n      itemsSpecies <<- c('Select Type',as.character(df[[3]]))\n      \n      shinyjs::show(id = \"spectroClip\", anim = FALSE)\n      shinyjs::show(id = \"clipInfo-container\", anim = FALSE)\n      updateSelectizeInput(session, \"annotationDrop\", label = \"Select an annotation\", choices =  currAnnList, selected = tail(currAnnList, 1))\n      shinyjs::html(\"timeMin\", paste0(\"Start Time \",round(minLast, digits = 2)))\n      shinyjs::html(\"timeMax\", paste0(\"End Time \",round(maxLast, digits = 2)))\n      shinyjs::html(\"maxFreq\", paste0(\"Max \", maxFreqLast))\n      shinyjs::html(\"minFreq\", paste0(\"Min \", minFreqLast))\n      shinyjs::html(\"meanFreq\", paste0(\"Mean \", meanFreqLast))\n      shinyjs::html(\"bandwidth\", paste0(\"Bandwidth \", bandwidthLast))\n      shinyjs::html(\"slope\", paste0(\"Slope \", slopeLast))\n      updateSelectizeInput(session, \"typeDropdown\", label = \"Type*\", choices =  itemsSpecies, selected = as.character(typeLast))\n      updateSelectizeInput(session, \"speciesDropdown\", label = \"Species*\", choices =  itemsType, selected = as.character(speciesLast))\n    }\n    else { # Otherwise just return since nothing to read\n      return()\n    }\n  }\n  \n  getStatusBarCount <- function() {\n    csv <- read.csv(depFilePath)\n    if(\"Annotation.\" %in% colnames(csv)){\n      # Couting the unique different sequences that have been already annotated\n      countAnnDone <- length(unique(csv[ ,9]))\n    }\n  }\n  \n  findFileInfo = function(firstTime) {\n    files <- list.files(depPath, all.files=F, recursive=T, include.dirs=T)\n    filesArray <<- 0\n    dateArray <<- 0\n    for (i in 1:length(files)) {\n      if (substrRight(files[i],4) == \".wav\") {\n        fileName <- paste0(depPath,\"/\",files[i])\n        wavFile <- substr(fileName, attr(regexpr('.*/', fileName),\"match.length\")+1, nchar(fileName))\n        timeStringLength <- regexpr('_.*_', wavFile)\n        matchedString <- timeStringLength + attr(timeStringLength, \"match.length\")-1\n        fileTime <- ''\n        if(firstTime) {\n          fileTime <- substr(wavFile, timeStringLength+1, matchedString-1)\n        } else {\n          string <- substr(wavFile, timeStringLength+1, matchedString-1)\n          fileTime <- gsub(\".*_\", \"\", string)\n        }\n        dateArray <<- c(dateArray, fileTime)\n        filesArray <<- c(filesArray, fileName)\n      }\n    }\n    findMaxAndMinFileDates(dateArray)\n  }\n  \n  findMaxAndMinFileTimes = function (filesArray){\n    timeArray <<- NULL\n    for (i in 2:length(filesArray)) {\n      timeArray <<- c(timeArray, file.info(filesArray[i])[[4]])\n    }\n    minTimeVar <<- as.POSIXct(min(timeArray), origin=\"1970-01-01\")\n    maxTimeVar <<- as.POSIXct(max(timeArray), origin=\"1970-01-01\")\n    output$minTime <- renderPrint({cat(as.character(minTimeVar))})\n    output$maxTime <- renderPrint({cat(as.character(maxTimeVar))})\n  }\n  \n  findMaxAndMinFileDates = function (dateArray){\n    timeArray <<- dateArray[rev(order(as.Date(ymd(dateArray), format = \"%m-%d-%Y\")))]\n    # minTimeVar <<- as.POSIXct(min(timeArray), origin=\"1970-01-01\")\n    # maxTimeVar <<- as.POSIXct(max(timeArray), origin=\"1970-01-01\")\n    minTimeVar <<- as.Date(ymd(timeArray[length(timeArray)]))\n    maxTimeVar <<- as.Date(ymd(timeArray[2]))\n    output$minTime <- renderPrint({cat(as.character(minTimeVar))})\n    output$maxTime <- renderPrint({cat(as.character(maxTimeVar))})\n  }\n})",
    "created" : 1479500229905.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1869854381",
    "id" : "D7501FF8",
    "lastKnownWriteTime" : 1485792725,
    "last_content_update" : 1485792725,
    "path" : "~/dev/emammal-soundBurst/server.R",
    "project_path" : "server.R",
    "properties" : {
        "docOutlineVisible" : "1"
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}